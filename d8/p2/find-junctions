#!/usr/bin/env ruby

# require "pry"
# require "pry-byebug"

class Point
  attr_accessor :x, :y, :z

  def initialize(x, y, z)
    self.x = x
    self.y = y
    self.z = z
  end

  def distance_to(other)
    ((x - other.x) ** 2) + ((y - other.y) ** 2) + ((z - other.z) ** 2)
  end

  def simple_distance_to(other)
    distance = (x - other.x).abs

    new_distance = (y - other.y).abs

    if new_distance > distance
      distance = new_distance
    end

    new_distance = (z - other.z).abs

    new_distance > distance ? new_distance : distance
  end

  def to_s = "(#{x}, #{y}, #{z})"
end

class Circuit
  def connections = @connections ||= Set.new
  def points = @points ||= []
  def initialize(starting_point) = add_point(starting_point)
  def add_point(point) = points << point

  def connect_points(new_point, existing_point)
    key = [new_point, existing_point]
    key.sort_by!(&:object_id)

    connections << key
  end

  def connect_circuit(other)
    other.points.each { |p| add_point(p) }
    other.connections.each do |connection|
      connections << connection
    end
  end

  def connected?(point1, point2)
    key = [point1, point2]
    key.sort_by!(&:object_id)

    connections.include?(key)
  end

  def size = points.size
end

class JunctionProblem
  attr_accessor :circuits, :last_connection1, :last_connection2

  def initialize(inputs_string)
    rows = inputs_string.split("\n")

    self.circuits = rows.map do |row|
      Circuit.new(Point.new(*row.split(",").map(&:to_i)))
    end
  end

  def perform_connections
    perform_connection until done?

    last_connection1.x * last_connection2.x
  end

  def done?
    puts circuits.size
    circuits.size == 1
  end

  def three_biggest_circuits = circuits.sort_by(&:size)[-3..]

  def perform_connection
    min_distance = nil
    closest_circuits = nil
    closest_points = nil

    circuits_size = circuits.size

    0.upto(circuits_size - 2).each do |circuit_index|
      circuit = circuits[circuit_index]

      circuit.points.each do |point|
        circuit_index.upto(circuits_size - 1).each do |other_circuit_index|
          other_circuit = circuits[other_circuit_index]

          other_circuit.points.each do |other_point|
            next if point == other_point

            if min_distance
              simple_distance = point.simple_distance_to(other_point)
              next if simple_distance > min_distance
            end

            distance = point.distance_to(other_point)

            if min_distance.nil? || distance < min_distance
              if other_circuit != circuit || !circuit.connected?(point, other_point)
                min_distance = distance
                closest_points = [point, other_point]
                closest_circuits = [circuit, other_circuit]
              end
            end
          end
        end
      end
    end

    connect_points(*closest_points, *closest_circuits)
  end

  def connect_points(point1, point2, circuit1, circuit2)
    unless circuit1 == circuit2
      connect_circuits(circuit1, circuit2)
    end
    circuit1.connect_points(point1, point2)
    self.last_connection1 = point1
    self.last_connection2 = point2
  end

  def connect_circuits(circuit1, circuit2)
    circuits.delete(circuit2)
    circuit1.connect_circuit(circuit2)
  end
end

inputs_string = File.read("inputs.txt")

junction_problem = JunctionProblem.new(inputs_string)
puts junction_problem.perform_connections
