#!/usr/bin/env ruby

# Looks like no directions repeat

# require "pry"
# require "pry-byebug"

class Range
  def merge(other)
    bounds = [*minmax, *other.minmax]
    self.class.new(bounds.min, bounds.max)
  end
end

class Point
  include Comparable

  def self.[](...) = new(...)

  attr_accessor :x, :y

  def initialize(x, y)
    self.x = x
    self.y = y
  end

  def to_s = "(#{x},#{y})"

  def ==(other)
    if other.is_a?(Point)
      other.x == x && other.y == y
    end
  end

  def eql?(other) = self == other

  def hash
    [x, y].hash
  end

  def <=>(other)
    cmp = y <=> other.y
    cmp.zero? ? x <=> other.x : cmp
  end
end

class Rectangle
  attr_accessor :corner1, :corner2

  def initialize(corner1, corner2)
    self.corner1 = corner1
    self.corner2 = corner2
  end

  def area
    ((corner1.x - corner2.x + 1) * (corner1.y - corner2.y + 1)).abs
  end

  def each_point
    x1 = corner1.x
    x2 = corner2.x
    y1 = corner1.y
    y2 = corner2.y

    if x1 > x2
      ulx = x2
      urx = x1
    else
      ulx = x1
      urx = x2
    end

    if y1 > y2
      uly = y2
      ury = y1
    else
      uly = y1
      ury = y2
    end

    (ulx..urx).each do |x|
      (uly..ury).each do |y|
        yield Point.new(x, y)
      end
    end
  end

  def upper_left_corner
    return @upper_left_corner if defined?(@upper_left_corner)

    x1 = corner1.x
    x2 = corner2.x
    y1 = corner1.y
    y2 = corner2.y

    ulx =  x1 > x2 ? x2 : x1
    uly =  y1 > y2 ? y2 : y1

    @upper_left_corner = Point.new(ulx, uly)
  end

  def lower_right_corner
    return @lower_right_corner if defined?(@lower_right_corner)

    x1 = corner1.x
    x2 = corner2.x
    y1 = corner1.y
    y2 = corner2.y

    lrx =  x1 > x2 ? x1 : x2
    lry =  y1 > y2 ? y1 : y2

    @lower_right_corner = Point.new(lrx, lry)
  end
end

class Floor
  attr_accessor :points, :border_tiles, :fill_from, :filled_tiles, :red_tiles_set,
                :neighbor_of, :filled_ranges

  def initialize(input_string)
    self.filled_ranges = {}
    self.neighbor_of = {}

    rows = input_string.split("\n")
    self.points = rows.map do |row|
      coordinates = row.split(",").map(&:to_i)
      Point[*coordinates]
    end

    self.red_tiles_set = points.to_set

    build_border_tiles
    fill
    puts "done filling!"
    union_ranges
  end

  def build_border_tiles
    self.border_tiles = Set.new
    self.fill_from = []
    self.filled_tiles = []

    first_point = points.first
    previous_point = first_point

    points.each do |next_point|
      fill_in_border_tiles(previous_point, next_point)
      previous_point = next_point
    end

    fill_in_border_tiles(points.last, first_point)

    fill_from.uniq!
    fill_from.sort!

    puts "done building border tiles!"
  end

  def fill_in_border_tiles(p1, p2)
    border_tiles << p1
    border_tiles << p2

    if p1.y == p2.y
      neighbor_of[p1] = p2
      neighbor_of[p2] = p1

      y = p1.y

      if p2.x > p1.x
        x1 = p1.x
        x2 = p2.x
      else
        x1 = p2.x
        x2 = p1.x
      end

      x1.upto(x2) do |x|
        p = Point[x, y]

        fill_from << p
        border_tiles << p
      end
    end
  end

  def fill
    until fill_from.empty?
      p = fill_from.shift
      p_is_red = red_tiles_set.include?(p)

      x = p.x
      below_p = p

      loop do
        below_p = Point[x, below_p.y + 1]

        puts below_p

        if border_tiles.include?(below_p)
          if red_tiles_set.include?(below_p)
            if p_is_red
              p_neighbor = neighbor_of[p]
              below_p_neighbor = neighbor_of[below_p]

              p_direction = p.x < p_neighbor.x ? :right : :left
              below_p_direction = below_p.x < below_p_neighbor.x ? :right : :left

              above_p_y = p.y - 1
              if p_direction == below_p_direction
                unless filled_ranges.any? { |r| r.member?(above_p_y) }
                  fill_from.delete(below_p)
                end
              elsif filled_ranges.any? { |r| r.member?(above_p_y) }
                fill_from.delete(below_p)
              end
            end
          else
            fill_from.delete(below_p)
          end

          a = filled_ranges[x] ||= []
          a << Range.new(p.y, below_p.y)

          break
        end
      end
    end

    border_tiles.each do |p|
      filled_tiles << p
    end
    self.border_tiles = nil
    self.fill_from = nil
    self.red_tiles_set = nil

    filled_tiles.uniq!
    filled_tiles.sort!
  end

  def union_ranges
    keys = filled_ranges.keys
    keys.each do |x|
      overlap_found = true

      ranges = filled_ranges[x]

      while overlap_found
        overlap_found = false

        0.upto(ranges.size - 2) do |range1_index|
          range1 = ranges[range1_index]

          (range1_index + 1).upto(ranges.size - 1) do |range2_index|
            range2 = ranges[range2_index]

            if range1.overlap?(range2)
              ranges.delete(range1)
              ranges.delete(range2)

              ranges << range1.merge(range2)

              overlap_found = true
              break
            end
          end

          break if overlap_found
        end
      end

      filled_ranges[x] = ranges
    end
  end

  def biggest_rectangle
    rectangles_size = rectangles.size

    rectangles.each.with_index do |rectangle, index|
      # puts "considering #{index} of #{rectangles_size}"

      found = true

      upper_left_corner = rectangle.upper_left_corner
      lower_right_corner = rectangle.lower_right_corner

      covered = false

      upper_left_corner.x.upto(lower_right_corner.x) do |x|
        range = (upper_left_corner.y..lower_right_corner.y)

        covered = filled_ranges[x].any? do |filled_range|
          filled_range.cover?(range)
        end

        break unless covered
      end

      return rectangle if covered
    end
  end

  def rectangles
    return @rectangles if @rectangles

    rectangles = []

    points_size = points.size

    0.upto(points_size - 2) do |corner1_index|
      corner1 = points[corner1_index]
      corner1_index.upto(points_size - 1) do |corner2_index|
        corner2 = points[corner2_index]

        rectangles << Rectangle.new(corner1, corner2)
      end
    end

    rectangles.sort_by!(&:area)
    rectangles.reverse!

    puts "done building rectangles!"

    @rectangles = rectangles
  end
end

input_string = File.read("inputs.txt")

floor = Floor.new(input_string)
puts floor.biggest_rectangle.area
