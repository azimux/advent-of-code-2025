#!/usr/bin/env ruby

require "pry"
require "pry-byebug"

class Point
  include Comparable

  def self.[](...) = new(...)

  attr_accessor :x, :y

  def initialize(x, y)
    self.x = x
    self.y = y
  end

  def to_s = "(#{x},#{y})"

  def ==(other)
    if other.is_a?(Point)
      other.x == x && other.y == y
    end
  end

  def eql?(other) = self == other

  def hash
    [x, y].hash
  end

  def <=>(other)
    cmp = y <=> other.y
    cmp.zero? ? x <=> other.x : cmp
  end
end

class Rectangle
  attr_accessor :x1, :x2, :y1, :y2

  def initialize(corner1, corner2)
    self.x1 = corner1.x
    self.x2 = corner2.x
    self.y1 = corner1.y
    self.y2 = corner2.y

    if x1 > x2
      self.x1, self.x2 = x2, x1
    end

    if y1 > y2
      self.y1, self.y2 = y2, y1
    end
  end

  def area
    (x2 - x1 + 1) * (y2 - y1 + 1)
  end

  def ul
    Point.new(x1, y1)
  end

  def ur
    Point.new(x2, y1)
  end

  def bl
    Point.new(x1, y2)
  end

  def br
    Point.new(x2, y2)
  end

  def points
    [ul, ur, bl, br]
  end

  def remove_overlapping_pieces(rectangle_to_break)
    contained_points, uncontained_points = rectangle_to_break.points.partition do |p|
      contains?(p)
    end

    case contained_points.size
    when 0
      our_points_contained_by_rectangle_to_break = points.find { |p| rectangle_to_break.contains?(p) }.sort

      case our_points_contained_by_rectangle_to_break.size
      when 0
        rectangle_to_break
      when 2
        case our_points_contained_by_rectangle_to_break
        when [ul, ur] # top
          [
            # left piece
            Rectangle.new(rectangle_to_break.ul, Point[x1, rectangle_to_break.y2]),
            # middle top
            Rectangle.new(ul, Point[x2, rectangle_to_break.y1]),
            # left piece
            Rectangle.new(rectangle_to_break.ur, Point[x2, rectangle_to_break.y2])
          ]
        when [ur, br] # right
          [
            # top piece
            Rectangle.new(rectangle_to_break.ul, Point[rectangle_to_break.x2, y1]),
            # middle right
            Rectangle.new(br, Point[rectangle_to_break.x2, y1]),
            # bottom piece
            Rectangle.new(rectangle_to_break.bl, Point[rectangle_to_break.x2, y2])
          ]
        when [ul, bl] # left
          [
            # top piece
            Rectangle.new(rectangle_to_break.ul, Point[rectangle_to_break.x2, y1]),
            # middle right
            Rectangle.new(bl, Point[rectangle_to_break.x1, y1]),
            # bottom piece
            Rectangle.new(rectangle_to_break.bl, Point[rectangle_to_break.x2, y2])
          ]
        when [bl, br] # bottom
          [
            # left piece
            Rectangle.new(rectangle_to_break.ul, Point[x1, rectangle_to_break.y2]),
            # middle bottom
            Rectangle.new(bl, Point[x2, rectangle_to_break.y2]),
            # left piece
            Rectangle.new(rectangle_to_break.ur, Point[x2, rectangle_to_break.y2])
          ]
        else
          raise "wtf"
        end
      when 4
        [
          # top row
          Rectangle.new(ul, rectangle_to_break.ul),
          Rectangle.new(ul, Point[x2, rectangle_to_break.y1]),
          Rectangle.new(ur, rectangle_to_break.ur),

          # middle row
          Rectangle.new(ul, Point[rectangle_to_break.x1, y2]),
          Rectangle.new(ur, Point[rectangle_to_break.x2, y2]),

          # bottom row
          Rectangle.new(bl, rectangle_to_break.bl),
          Rectangle.new(bl, Point[x2, rectangle_to_break.y2]),
          Rectangle.new(br, rectangle_to_break.br)
        ]
      end
    when 1
      corner1 = points.find { |p| rectangle_to_break.contains?(p) }

      uncontained_points.map do |up|
        Rectangle.new(corner1, up)
      end
    when 2
      # 1r
      # will contain the two uncontained points.
      up1, up2 = uncontained_points
      cp1 = contained_points.first

      corner1 = up1

      if up1.x == up2.x
        # we contain a vertical edge
        x = if cp1.x < up1.x
              # we contain the left edge of the rectangle_to_break
              x2 - 1
            else
              # we contain the right edge of the rectangle_to_break
              x1 + 1
            end

        corner2 = Point[x, up2.y]
      else
        # we contain a horizontal edge
        y = if cp1.y < up1.y
              # we contain the top edge of the rectangle_to_break
              y2 - 1
            else
              # we contain the bottom edge of the rectangle_to_break
              y1 + 1
            end

        corner2 = Point[up2.x, y]
      end

      Rectangle.new(corner1, corner2)
    end
  end

  def contains?(point)
    point.x.between?(x1, x2) && point.y.between?(y1, y2)
  end
end

class Ring
  class Vertex
    attr_accessor :point, :prev, :next

    def initialize(point)
      self.point = point
    end

    def right
      vertex = if prev.y == y
                 prev
               elsif self.next.y == y
                 self.next
               end

      if vertex && vertex.x > x
        vertex
      end
    end

    def down
      vertex = if prev.x == x
                 prev
               elsif self.next.x == x
                 self.next
               end

      if vertex && vertex.y > y
        vertex
      end
    end

    def y = point.y
    def x = point.x
    def to_s = point.to_s

    def y=(y)
      point.y = y
    end
  end

  attr_accessor :head, :size

  def initialize(points)
    points = points.dup

    self.size = points.size

    first_point = points.first

    vertex = Vertex.new(first_point)
    self.head = vertex
    prev_vertex = vertex

    points[1..].each do |point|
      next_vertex = Vertex.new(point)
      prev_vertex.next = next_vertex
      next_vertex.prev = prev_vertex

      prev_vertex = next_vertex
    end

    prev_vertex.next = head
    head.prev = prev_vertex
  end

  def delete(point_or_vertex)
    case point_or_vertex
    when Point
      vertex = head

      size.times do
        if vertex.point == point_or_vertex
          return delete_vertex(vertex)
        end

        vertex = vertex.next
      end
    when Vertex
      delete_vertex(point_or_vertex)
    end
  end

  def delete_vertex(vertex)
    if size == 1
      self.size = 0
      self.head = nil
    else
      self.size -= 1

      prev_vertex = vertex.prev
      next_vertex = vertex.next

      if vertex == head
        self.head = next_vertex
      end

      prev_vertex.next = next_vertex
      next_vertex.prev = prev_vertex
    end
  end

  def points
    vertex = head
    points = []

    return points unless head

    begin
      points << vertex.point
      vertex = vertex.next
    end until vertex == head

    points
  end

  def empty?
    size == 0
  end

  def extract_rectangles
    rectangles = []
    rectangles << extract_rectangle until empty?
    rectangles
  end

  def extract_rectangle
    top_left = smallest_vertex

    top_right = top_left.right

    bottom_left = top_left.down
    bottom_right = top_right.down

    rectangle = nil

    if bottom_left.y > bottom_right.y
      rectangle = Rectangle.new(top_left.point, bottom_right.point)

      delete(top_right)
      top_left.y = bottom_right.y

      delete(bottom_right)
    elsif bottom_left.y < bottom_right.y
      rectangle = Rectangle.new(top_right.point, bottom_left.point)

      delete(top_left)
      top_right.y = bottom_left.y

      delete(bottom_left)
    else
      rectangle = Rectangle.new(top_left.point, bottom_right.point)

      delete(top_left)
      delete(bottom_left)
      delete(top_right)
      delete(bottom_right)
    end

    rectangle
  end

  def smallest_vertex
    return head if size == 1

    smallest_vertex = head
    smallest_point = head.point
    vertex = head.next

    begin
      vertex_point = vertex.point

      if vertex_point < smallest_point
        smallest_vertex = vertex
        smallest_point = vertex_point
      end

      vertex = vertex.next
    end until vertex == head

    smallest_vertex
  end
end

class Floor
  attr_accessor :points, :filled_tiles, :red_tiles_set, :green_rectangles, :ring

  def initialize(points)
    self.points = points
    self.ring = Ring.new(points)
    self.red_tiles_set = points.to_set

    extract_green_rectangles
  end

  def extract_green_rectangles
    self.green_rectangles = ring.extract_rectangles
    self.ring = nil
  end

  def biggest_rectangle
    rectangles.each.with_index do |rectangle, index|
      # puts "considering #{index} of #{rectangles_size}"
    end
  end

  def rectangles
    return @rectangles if @rectangles

    rectangles = []

    points_size = points.size

    0.upto(points_size - 2) do |corner1_index|
      corner1 = points[corner1_index]
      corner1_index.upto(points_size - 1) do |corner2_index|
        corner2 = points[corner2_index]

        rectangles << Rectangle.new(corner1, corner2)
      end
    end

    rectangles.sort_by!(&:area)
    rectangles.reverse!

    puts "done building rectangles!"

    @rectangles = rectangles
  end
end

def parse_points(filename)
  input_string = File.read(filename)
  rows = input_string.split("\n")

  rows.map do |row|
    coordinates = row.split(",").map(&:to_i)
    Point[*coordinates]
  end
end

points = parse_points("inputs.txt")

floor = Floor.new(points)

rectangles = floor.green_rectangles

puts rectangles.size
