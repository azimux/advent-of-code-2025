#!/usr/bin/env ruby

# Looks like no directions repeat

require "pry"
require "pry-byebug"

class Point
  include Comparable

  def self.[](...) = new(...)

  attr_accessor :x, :y

  def initialize(x, y)
    self.x = x
    self.y = y
  end

  def to_s = "(#{x},#{y})"

  def ==(other)
    if other.is_a?(Point)
      other.x == x && other.y == y
    end
  end

  def eql?(other) = self == other

  def hash
    [x, y].hash
  end

  def <=>(other)
    cmp = y <=> other.y
    cmp.zero? ? x <=> other.x : cmp
  end
end

class Floor
  attr_accessor :points, :border_tiles, :fill_from, :filled_tiles, :red_tiles_set,
                :neighbor_of

  def initialize(input_string)
    self.neighbor_of = {}

    rows = input_string.split("\n")
    self.points = rows.map do |row|
      coordinates = row.split(",").map(&:to_i)
      Point[*coordinates]
    end

    self.red_tiles_set = points.to_set

    build_border_tiles
    fill
  end

  def build_border_tiles
    self.border_tiles = Set.new
    self.fill_from = []
    self.filled_tiles = []

    first_point = points.first
    previous_point = first_point

    points.each do |next_point|
      fill_in_border_tiles(previous_point, next_point)
      previous_point = next_point
    end

    fill_in_border_tiles(points.last, first_point)

    fill_from.uniq!
    fill_from.sort!
  end

  def fill_in_border_tiles(p1, p2)
    border_tiles << p1
    border_tiles << p2

    if p1.x == p2.x
      x = p1.x

      if p2.y > p1.y
        y1 = p1.y
        y2 = p2.y
      else
        y1 = p2.y
        y2 = p1.y
      end

      # (y1 + 1).upto(y2 - 1) { |y| border_tiles << Point[x, y] }
    else
      neighbor_of[p1] = p2
      neighbor_of[p2] = p1

      y = p1.y

      if p2.x > p1.x
        x1 = p1.x
        x2 = p2.x
      else
        x1 = p2.x
        x2 = p1.x
      end

      x1.upto(x2) do |x|
        p = Point[x, y]

        fill_from << p
        border_tiles << p
      end
    end
  end

  def fill
    until fill_from.empty?
      p = fill_from.shift
      p_is_red = red_tiles_set.include?(p)

      x = p.x
      below_p = p

      loop do
        below_p = Point[x, below_p.y + 1]

        if border_tiles.include?(below_p)
          if red_tiles_set.include?(below_p)
            if p_is_red
              p_neighbor = neighbor_of[p]
              below_p_neighbor = neighbor_of[below_p]

              p_direction = p.x < p_neighbor.x ? :right : :left
              below_p_direction = below_p.x < below_p_neighbor.x ? :right : :left

              above_p = Point.new(x, p.y - 1)

              if p_direction == below_p_direction && !filled_tiles.include?(above_p)
                fill_from.delete(below_p)
              end

              if p_direction != below_p_direction && filled_tiles.include?(above_p)
                fill_from.delete(below_p)
              end

              if p_direction == below_p_direction
                unless filled_tiles.include?(above_p)
                  fill_from.delete(below_p)
                end
              elsif filled_tiles.include?(above_p)
                fill_from.delete(below_p)
              end
            end
          else
            fill_from.delete(below_p)
          end

          break
        else
          filled_tiles << below_p
        end
      end
    end

    border_tiles.each do |p|
      filled_tiles << p
    end
    self.border_tiles = nil
    self.fill_from = nil
    self.red_tiles_set = nil

    filled_tiles.uniq!
    filled_tiles.sort!
  end

  def biggest_rectangle
    points_size = points.size
    biggest_area = 0

    0.upto(points_size - 2) do |corner1_index|
      corner1 = points[corner1_index]
      corner1_index.upto(points_size - 1) do |corner2_index|
        corner2 = points[corner2_index]

        area = ((corner1.x - corner2.x + 1) * (corner1.y - corner2.y + 1)).abs

        if area > biggest_area
          biggest_area = area
        end
      end
    end

    biggest_area
  end
end

input_string = File.read("inputs_test.txt")

floor = Floor.new(input_string)
