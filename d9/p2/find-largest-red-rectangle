#!/usr/bin/env ruby

require "pry"
require "pry-byebug"

class Point
  include Comparable

  def self.[](...) = new(...)

  attr_accessor :x, :y

  def initialize(x, y)
    self.x = x
    self.y = y
  end

  def to_s = "(#{x},#{y})"

  def ==(other)
    if other.is_a?(Point)
      other.x == x && other.y == y
    end
  end

  def eql?(other) = self == other

  def hash
    [x, y].hash
  end

  def <=>(other)
    cmp = y <=> other.y
    cmp.zero? ? x <=> other.x : cmp
  end
end

class Rectangle
  attr_accessor :x1, :x2, :y1, :y2

  def initialize(corner1, corner2)
    self.x1 = corner1.x
    self.x2 = corner2.x
    self.y1 = corner1.y
    self.y2 = corner2.y

    if x1 > x2
      self.x1, self.x2 = x2, x1
    end

    if y1 > y2
      self.y1, self.y2 = y2, y1
    end
  end

  def area
    (x2 - x1 + 1) * (y2 - y1 + 1)
  end
end

class Ring
  class Vertex
    attr_accessor :point, :prev, :next

    def initialize(point)
      self.point = point
    end

    def right
      vertex = if prev.y == y
                 prev
               elsif self.next.y == y
                 self.next
               end

      if vertex && vertex.x > x
        vertex
      end
    end

    def down
      vertex = if prev.x == x
                 prev
               elsif self.next.x == x
                 self.next
               end

      if vertex && vertex.y > y
        vertex
      end
    end

    def y = point.y
    def x = point.x
    def to_s = point.to_s

    def y=(y)
      point.y = y
    end
  end

  attr_accessor :head, :size

  def initialize(points)
    self.size = points.size

    first_point = points.first

    vertex = Vertex.new(first_point)
    self.head = vertex
    prev_vertex = vertex

    points[1..].each do |point|
      next_vertex = Vertex.new(point)
      prev_vertex.next = next_vertex
      next_vertex.prev = prev_vertex

      prev_vertex = next_vertex
    end

    prev_vertex.next = head
    head.prev = prev_vertex
  end

  def delete(point_or_vertex)
    case point_or_vertex
    when Point
      vertex = head

      size.times do
        if vertex.point == point_or_vertex
          return delete_vertex(vertex)
        end

        vertex = vertex.next
      end
    when Vertex
      delete_vertex(point_or_vertex)
    end
  end

  def delete_vertex(vertex)
    if size == 1
      self.size = 0
      self.head = nil
    else
      self.size -= 1

      prev_vertex = vertex.prev
      next_vertex = vertex.next

      if vertex == head
        self.head = next_vertex
      end

      prev_vertex.next = next_vertex
      next_vertex.prev = prev_vertex
    end
  end

  def points
    vertex = head
    points = []

    return points unless head

    begin
      points << vertex.point
      vertex = vertex.next
    end until vertex == head

    points
  end

  def empty?
    size == 0
  end

  def extract_rectangle
    top_left = smallest_vertex

    top_right = top_left.right

    bottom_left = top_left.down
    bottom_right = top_right.down

    rectangle = nil

    if bottom_left.y > bottom_right.y
      rectangle = Rectangle.new(top_left.point, bottom_right.point)

      delete(top_right)
      top_left.y = bottom_right.y

      delete(bottom_right)
    elsif bottom_left.y < bottom_right.y
      rectangle = Rectangle.new(top_right.point, bottom_left.point)

      delete(top_left)
      top_right.y = bottom_left.y

      delete(bottom_left)
    else
      rectangle = Rectangle.new(top_left.point, bottom_right.point)

      delete(top_left)
      delete(bottom_left)
      delete(top_right)
      delete(bottom_right)
    end

    rectangle
  end

  def smallest_vertex
    return head if size == 1

    smallest_vertex = head
    smallest_point = head.point
    vertex = head.next

    begin
      vertex_point = vertex.point

      if vertex_point < smallest_point
        smallest_vertex = vertex
        smallest_point = vertex_point
      end

      vertex = vertex.next
    end until vertex == head

    smallest_vertex
  end
end

class Floor
  attr_accessor :points, :fill_from, :filled_tiles, :red_tiles_set

  def initialize(points)
    self.points = points
    self.red_tiles_set = points.to_set
  end

  def biggest_rectangle
    rectangles_size = rectangles.size

    rectangles.each.with_index do |rectangle, index|
      # puts "considering #{index} of #{rectangles_size}"

      found = true

      upper_left_corner = rectangle.upper_left_corner
      lower_right_corner = rectangle.lower_right_corner

      covered = false

      upper_left_corner.x.upto(lower_right_corner.x) do |x|
        range = (upper_left_corner.y..lower_right_corner.y)

        covered = filled_ranges[x].any? do |filled_range|
          filled_range.cover?(range)
        end

        break unless covered
      end

      return rectangle if covered
    end
  end

  def rectangles
    return @rectangles if @rectangles

    rectangles = []

    points_size = points.size

    0.upto(points_size - 2) do |corner1_index|
      corner1 = points[corner1_index]
      corner1_index.upto(points_size - 1) do |corner2_index|
        corner2 = points[corner2_index]

        rectangles << Rectangle.new(corner1, corner2)
      end
    end

    rectangles.sort_by!(&:area)
    rectangles.reverse!

    puts "done building rectangles!"

    @rectangles = rectangles
  end
end

def parse_points(filename)
  input_string = File.read(filename)
  rows = input_string.split("\n")

  rows.map do |row|
    coordinates = row.split(",").map(&:to_i)
    Point[*coordinates]
  end
end

points = parse_points("inputs_test.txt")

floor = Floor.new(points)
puts floor.rectangles.size

ring = Ring.new(points)

rectangle = ring.extract_rectangle

binding.pry
puts "asdf"
