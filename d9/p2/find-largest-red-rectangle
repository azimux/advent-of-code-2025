#!/usr/bin/env ruby

# Looks like no directions repeat

require "pry"
require "pry-byebug"

class Point
  include Comparable

  def self.[](...) = new(...)

  attr_accessor :x, :y

  def initialize(x, y)
    self.x = x
    self.y = y
  end

  def to_s = "(#{x},#{y})"

  def ==(other)
    if other.is_a?(Point)
      other.x == x && other.y == y
    end
  end

  def eql?(other) = self == other

  def hash
    [x, y].hash
  end

  def <=>(other)
    cmp = y <=> other.y
    cmp.zero? ? x <=> other.x : cmp
  end
end

class Rectangle
  attr_accessor :corner1, :corner2

  def initialize(corner1, corner2)
    self.corner1 = corner1
    self.corner2 = corner2
  end

  def area
    ((corner1.x - corner2.x + 1) * (corner1.y - corner2.y + 1)).abs
  end

  def each_point
    x1 = corner1.x
    x2 = corner2.x
    y1 = corner1.y
    y2 = corner2.y

    if x1 > x2
      ulx = x2
      urx = x1
    else
      ulx = x1
      urx = x2
    end

    if y1 > y2
      uly = y2
      ury = y1
    else
      uly = y1
      ury = y2
    end

    (ulx..urx).each do |x|
      (uly..ury).each do |y|
        yield Point.new(x, y)
      end
    end
  end
end

class Floor
  attr_accessor :points, :border_tiles, :fill_from, :filled_tiles, :red_tiles_set,
                :neighbor_of

  def initialize(input_string)
    self.neighbor_of = {}

    rows = input_string.split("\n")
    self.points = rows.map do |row|
      coordinates = row.split(",").map(&:to_i)
      Point[*coordinates]
    end

    self.red_tiles_set = points.to_set

    build_border_tiles
    fill
    puts "done filling!"
  end

  def build_border_tiles
    self.border_tiles = Set.new
    self.fill_from = []
    self.filled_tiles = []

    first_point = points.first
    previous_point = first_point

    points.each do |next_point|
      fill_in_border_tiles(previous_point, next_point)
      previous_point = next_point
    end

    fill_in_border_tiles(points.last, first_point)

    fill_from.uniq!
    fill_from.sort!

    puts "done building border tiles!"
  end

  def fill_in_border_tiles(p1, p2)
    border_tiles << p1
    border_tiles << p2

    if p1.x == p2.x
      x = p1.x

      if p2.y > p1.y
        y1 = p1.y
        y2 = p2.y
      else
        y1 = p2.y
        y2 = p1.y
      end

      # (y1 + 1).upto(y2 - 1) { |y| border_tiles << Point[x, y] }
    else
      neighbor_of[p1] = p2
      neighbor_of[p2] = p1

      y = p1.y

      if p2.x > p1.x
        x1 = p1.x
        x2 = p2.x
      else
        x1 = p2.x
        x2 = p1.x
      end

      x1.upto(x2) do |x|
        p = Point[x, y]

        fill_from << p
        border_tiles << p
      end
    end
  end

  def fill
    until fill_from.empty?
      p = fill_from.shift
      p_is_red = red_tiles_set.include?(p)

      x = p.x
      below_p = p

      loop do
        below_p = Point[x, below_p.y + 1]

        if border_tiles.include?(below_p)
          if red_tiles_set.include?(below_p)
            if p_is_red
              p_neighbor = neighbor_of[p]
              below_p_neighbor = neighbor_of[below_p]

              p_direction = p.x < p_neighbor.x ? :right : :left
              below_p_direction = below_p.x < below_p_neighbor.x ? :right : :left

              above_p = Point.new(x, p.y - 1)

              if p_direction == below_p_direction && !filled_tiles.include?(above_p)
                fill_from.delete(below_p)
              end

              if p_direction != below_p_direction && filled_tiles.include?(above_p)
                fill_from.delete(below_p)
              end

              if p_direction == below_p_direction
                unless filled_tiles.include?(above_p)
                  fill_from.delete(below_p)
                end
              elsif filled_tiles.include?(above_p)
                fill_from.delete(below_p)
              end
            end
          else
            fill_from.delete(below_p)
          end

          break
        else
          filled_tiles << below_p
        end
      end
    end

    border_tiles.each do |p|
      filled_tiles << p
    end
    self.border_tiles = nil
    self.fill_from = nil
    self.red_tiles_set = nil

    filled_tiles.uniq!
    filled_tiles.sort!
  end

  def biggest_rectangle
    rectangles_size = rectangles.size

    rectangles.each.with_index do |rectangle, index|
      puts "considering #{index} of #{rectangles_size}"

      found = true

      rectangle.each_point do |point|
        unless filled_tiles.include?(point)
          found = false
          break
        end
      end

      return rectangle if found
    end
  end

  def rectangles
    return @rectangles if @rectangles

    rectangles = []

    points_size = points.size

    0.upto(points_size - 2) do |corner1_index|
      corner1 = points[corner1_index]
      corner1_index.upto(points_size - 1) do |corner2_index|
        corner2 = points[corner2_index]

        rectangles << Rectangle.new(corner1, corner2)
      end
    end

    rectangles.sort_by!(&:area)
    rectangles.reverse!

    puts "done building rectangles!"

    @rectangles = rectangles
  end
end

input_string = File.read("inputs.txt")

floor = Floor.new(input_string)
puts floor.biggest_rectangle.area
